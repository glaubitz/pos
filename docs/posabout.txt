pOS * - An Introduction* Note that "pOS" is the prelimenary project name.Back in 1999 I stumbled accross a small Unix-clone calledLunix for my Commodore C64. I was fascinated by theprofessional system and user-interface design. Shortlyafter I decided to write my own operating system for theC64.I called the first piece of code "KeyDOS" and it was a merecommand-line-interface written in BASIC. It knew a fewbasic DOS-commands like formatting, deleting, renamingfiles and loading programs. But it was written in 2 days.At this time I had no real idea of what's going on insidean operating system kernel.The first things I heard about kernels was that they restrictthe direct access of a program with the hardware, so I thoughtthe programs must be running in a virtual machine like theone I knew from Java. I did not know that the direct hardware-access restriction was limited to device-operation only. Iinterpreted from that restriction that the program-codeis not actually running on the CPU but the operating systemis interpreting the program-code. As I began writing the program-code for my 2 attempt for an operating system I realizedquite soon that I must have misunderstood the term"restriction". It was very time-consuming writing operationcode for every 6502-opcode and so the "final" versionof "OS64" knew only around 20 of the more than 100 6502-instructions. OS64 was written in assembly and was intendedto be typed into a assembler-monitor. The assembly wasextremely buggy and it never really worked.Approximately at the same time I turned my back to Java andlearnt C++ as I had learnt that Java is rather appropriatefor web-applications than for conventional programs andeven operating systems. Still infected with the "my ownoperating system"-virus I started my third attemptfor an operating system, this time it should be completelywritten in C, I simply called it "OS64 2.0". I stilldidn't know really how programs were running in operatingsystem environments, but at least I knew then that multi-taskingis achieved by letting the CPU execute the code of everyrunning task circularily, i.e. task A, task B, task C, task Atask B, and so on. As I still had no good idea about OS-designI knew the third attempt would be doomed before it was finished.I wrote a small shell in assembly then with the knowlegde I hadso far but I never finished it though it was very simple andeasy, but I didn't want an assembly version of "KeyDOS" soI abandoned it and tried to continue "OS64 2.0".By that time I already had experimented alot with Linux(must have been 2.0.x or 2.2.x-series) and also studiedthe kernel sources and learnt more and more about OS-design(the Linux was not my only source, but it was my main source).I also downloaded the historical version 0.0.1 of Linux whichis way easier to read and understand than the newer series.Then one night in October 2000 I couldn't sleep my brain suddenlygot flashed and I had the name "pOS" floating around my headand "pOS" was the acronym for "portable Operating System". Ihad the idea to write a generic OS-kernel and only a smallhardware-specific BIOS-code (I did not use the driver conceptby then). The BIOS-code was written in assembly, the kernelin pure C. When I started pOS I had learnt alot from Linuxand co and I had understand the task-switching over timer-interrupt (though I initially mixed up the NMI with thetimer-interrupt on my C64, but this did not change thebasic idea). As I know had I rough idea of the design Ibegan to develop and to code and I changed parts of the designalmost every time I was working on pOS. Then, around May 2001I finally had a working version of the C64-bootloader code,but I only had a dummy-kernel to load for the boot-code. Butthis small working piece of code sparkled the strong willinside me to finish pOS and to have my own working operatingsystem, no matter how long developing would take.Now, in September 2003, the system-design is 100% completeand needs only to be implemented, refined and bug-fixed.It may only be a year or so, and pOS will be finallyworking. As a proove of my progress I have to the sizeof the compressed kernel sources. In January 2001, thecompressed sources were about 25k large, now it's over120k. I've added alot of documentation, draft-code andalot of working code (theoretically, nothing exceptforthe boot-code has ever been compiled). There is anHTML-documentation for programmers being worked on andthere's also a small (non-public) website which keepstrack of the pOS-development. So probably in near futurethe news on this site will proclaim the release of version0.0.1 of the pOS-kernel. The first will be publishedon the real web and I hope I can get some CommodoreFTP-servers to store the sources for download to usersworldwide.There are also plans for a pOS graphics library and fora simple graphical user-interface and even for a simplehome-brew computer (probably 68k-based) to run pOSfrom ROM. But that's all distant future and meresome drafts that may also never be put into reality.So for this time the pOS development progress isat around 70 percent, when the status is 100 percent,this document will certainly get an update.